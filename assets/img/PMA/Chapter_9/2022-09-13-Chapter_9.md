---
layout: post
title: PMA - 
subtitle: Chapter 9 - Labs Walkthrough
#cover-img: /assets/img/path.jpg
readtime: true
#thumbnail-img: /assets/img/thumb.png
#share-img: /assets/img/path.jpg
tags: [books, PracticalMalwareAnalysis, debugger, ollydbg, idapro]
---

# Lab 9-1
## **Full Analysis** available after the questions sections.

Analyze the malware found in the file Lab09-01.exe using OllyDbg and IDA
Pro to answer the following questions. This malware was initially analyzed in
the Chapter 3 labs using basic static and dynamic analysis techniques.

Questions

1. How can you get this malware to install itself?



2. What are the command-line options for this program? What is the password requirement?



3. How can you use OllyDbg to permanently patch this malware, so that it doesnâ€™t require the special command-line password?



4. What are the host-based indicators of this malware?




5. What are the different actions this malware can be instructed to take via the network?




6. Are there any useful network-based signatures for this malware?



# Full Analysis

As seen in Figure 1.1, our main function starts by comparing the argc with 1. So, if there is one argument specified for this malware upon running, the jump to _loc_402B1D_ will be taken.

![Figure 1.1](/assets/img/PMA/Chapter_9/Lab9-1/Figure1.1)
<p align="center"> Figure 1.1 </p> 

For now, let's follow the left side, the one where the jump is not taken.  
In Figure 2.1, we can see that there is a call to _sub_401000_ made.

![Figure 2.1](/assets/img/PMA/Chapter_9/Lab9-1/Figure2.1)
<p align="center"> Figure 2.1 </p> 

Let's look into that in Figure 3.1.

![Figure 3.1](/assets/img/PMA/Chapter_9/Lab9-1/Figure3.1)
<p align="center"> Figure 3.1 </p> 

In here, the malware checks for a registry key, _SOFTWARE\\Microsoft\\XPS_. If it is found, it checks for _Configuration_. When that is also found, the handle to the object is closed and EAX stores the value 1. If it is not found, the program returns to _402B03_, so right where we were in Figure 2.1.

We can name this function _query_regkey_XPS_ for easier reading.

Now, let's keep following the course of action in Figure 2.1. We can see that the EAX register is checked if it is 0. If it is 0 (**if the registry key is not found**), it jumps to _402B13_. At this address, there is a call made to _sub_402410_, so let's look into that in Figure 4.1.

![Figure 4.1](/assets/img/PMA/Chapter_9/Lab9-1/Figure4.1)
<p align="center"> Figure 4.1 </p> 

The malware uses _GetModuleFileNameA_ which means that it wants to get the full path of where it is located.  Then, it is using _GetShortPathNameA_ to get the short path of the file. 

Also, really interesting for us, is the presence of __/c del__, which is a sign that the malware might try to delete something.
(_/c_ is usually used to create a new shell, execute the provided command and exit from the shell automatically._del_ is used to delete one or more files) This, in combination with the functions mentioned above, gives us the clue that the malware would try to delete itself. 

At the bottom of the figure, _repne scasb_ is called. _repne_ (repeat while not equal) combined with _scasb_ (scan string) are used for block comparions of words.  We will see much easily how this works in the debugger.

Furthermore, in Figure 4.2, we can see that there are a lot more string comparions made, especially with _>> NULL_(this redirects the output to the NUL device. It's basically a virtual black hole. It is a way of not sending any output to the console).

![Figure 4.2](/assets/img/PMA/Chapter_9/Lab9-1/Figure4.2)
<p align="center"> Figure 4.2 </p>

In the end, as expected, a _cmd.exe_ shell is created that will run with the above mentioned arguments.

With all the information that we have this far, we can name the function as _self_delete_.

We've come to an end with this left side of the main function.
Let's open the debugger OllyDbg (Figure 5.1) and set a breakpoint at the address of our main function, _0x402AF0_ and run the program. We can do this by pressing Ctrl+G and specifying the desired address. From here, we will run (F9) and then press F7 to step into different instructions, and jump over windows functions with F8.

![Figure 5.1](/assets/img/PMA/Chapter_9/Lab9-1/Figure5.1)
<p align="center"> Figure 5.1 </p>


Now, let's press F7 a few times until we get to the first conditional jump. As seen in IDA, this jump was the one checking if we had any arguments upon launching the malware. As seen in Figure 5.2, the jump is not taken. 


![Figure 5.2](/assets/img/PMA/Chapter_9/Lab9-1/Figure5.2)
<p align="center"> Figure 5.2 </p>

Then, a call is being made to the function at _401000_, which we named _query_regkey_XPS_, as seen in Figure 5.3.

![Figure 5.3](/assets/img/PMA/Chapter_9/Lab9-1/Figure5.3)
<p align="center"> Figure 5.3 </p>

In Figure 5.4, we can see that after the execution of the _RegOpenKeyExA_ function, the EAX register holds the 2 value, meaning that it the call to the function wasn't succesful. So, the jump will not be taken.


![Figure 5.4](/assets/img/PMA/Chapter_9/Lab9-1/Figure5.4)
<p align="center"> Figure 5.4 </p>


Then, the function returns, EAX is compared to 0. After that, the function named by us as _self_delete_ is being called.
In here, we can easily observe what the malware does. In Figure 5.5, we see how it used _GetModuleFileName_ to get the full path of the executable. 

![Figure 5.5](/assets/img/PMA/Chapter_9/Lab9-1/Figure5.5)
<p align="center"> Figure 5.5 </p>

After a few iterations in _repne scasb_, we observe how it checks the string _/c del_ in Figure 5.6.

![Figure 5.6](/assets/img/PMA/Chapter_9/Lab9-1/Figure5.6)
<p align="center"> Figure 5.6 </p>

In the end of the function, in Figure 5.7 our assumption is confirmed. EAX stores the command _ /c del PathOfFile >> NULL _ , meaning that the malware will delete itself.

Let's apply what we know for now and reopen the malware in the debugger. This time we will specify a random argument so that we will follow the other chain of code. I've randomly chosen _exec_,as seen in Figure 6.1.  

![Figure 6.1](/assets/img/PMA/Chapter_9/Lab9-1/Figure6.1)
<p align="center"> Figure 6.1 </p>


Let's now go to _402B01_ which is the address of the jump, made possible by providing an argument. 

In Figure 6.2, we can see that now the jump has been taken because we provided an argument to the malware.

![Figure 6.2](/assets/img/PMA/Chapter_9/Lab9-1/Figure6.2)
<p align="center"> Figure 6.2 </p>

Now, we will follow address _0x402B1D_, to which we would have jumped if we would have had one argument upon running the malware.

Further down, EDX stores the argument that we passed to the malware. In our case, "exec".

![Figure 6.3](/assets/img/PMA/Chapter_9/Lab9-1/Figure6.3)
<p align="center"> Figure 6.3 </p>

Then, it is passed to EAX before calling _sub_402510_. 

Figure 6.4 shows the function _sub_402510_. At _00402539_ EDX, which holds the ascii character "e" from our "exec" string, is compared to 61. This value represents "a" in ASCII. So, the jump is not taken. Because the jump is not taken, the function will return and it will call, in the end, the function _self_delete_.

![Figure 6.4](/assets/img/PMA/Chapter_9/Lab9-1/Figure6.4)
<p align="center"> Figure 6.4 </p>

(**Note_1**) Now, if we try with "a" as an argument, we encounter the follow chain of code. Inside _402510_, ECX is compared with 4 (the value that is stored in ECX from our "a" character is 1), so the jump is not taken. (Figure 6.5). 

![Figure 6.5](/assets/img/PMA/Chapter_9/Lab9-1/Figure6.5)
<p align="center"> Figure 6.5 </p>

So, we jump to _004025A0_, where the function returns us to _402B33_ which is right after the step where we check if argc==1. EAX is compared to 0, and the jump at _402B38_ to _402B3F_ is not taken, so we follow _402410_ which is our _self_delete_ function. So, we wrote a wrong input to the malware.

The jump that we failed to take was at __Note_1__. ECX compares the number of characters from our argument with 4. So, let's use "aaaa" as our input.

Now, in Figure 6.6, we can see that the jump is taken. :) Hooray ! Let's keep going. 

![Figure 6.6](/assets/img/PMA/Chapter_9/Lab9-1/Figure6.6)
<p align="center"> Figure 6.6 </p>

I've kept an eye on IDA ever since debugging this sample. Let's look at Figure 6.7, to figure out where we are right now.

![Figure 6.7](/assets/img/PMA/Chapter_9/Lab9-1/Figure6.7)
<p align="center"> Figure 6.7 </p>

We've already compared our first character with "a", but then, in the second block after the jump is taken, we can see some arithmetic operations being done that aren't that easy to spot in IDA. So, let's go back to OllyDBG to figure out what's going on.

In Figure 6.8, in the red rectangle, there is a substraction being made. It "substracts" the second character from the first one. Then, it is compared to 1. So, if the difference between them has to be 1, it means that the second character should be 62 in hex. 62 in hex represents "b" in ASCII.

![Figure 6.8](/assets/img/PMA/Chapter_9/Lab9-1/Figure6.8)
<p align="center"> Figure 6.8 </p>

With this information in mind, let's run our program with "abcg". From the IDA view, it is clear that the next character will be "c". Let's see what's happening next.

In the red rectangle from Figure 6.9, the next comparison takes place. First, 1 is added to AL, which holds the value "c". So, it becomes "d". This value is further compared with our "g" that represents, in our case, 67. The jump will not be taken. So let's make the necessary changes and run the malware once more, but with "abcd" as our arguments.

![Figure 6.9](/assets/img/PMA/Chapter_9/Lab9-1/Figure6.9)
<p align="center"> Figure 6.9 </p>

After confirming that "d" is the last character, 1 is saved into the EAX register and the function returns. We can rename this function _check_abcd_argument_.

Figure 6.10 shows what follows our _check_abcd_argument_ function. EAX is compared to 0. The value that was saved in it after the function call is 1, so we will jump to the right block, to address _402B3F_.

![Figure 6.10](/assets/img/PMA/Chapter_9/Lab9-1/Figure6.10)
<p align="center"> Figure 6.10 </p>

Two strings are being compared which are not identified by IDA. But, after double-clicking on _byte_40C170_ and pressing the "A" key,  it's clear that the "Str2" value is "-in". (Hex values starting with 2 have an ASCII representation. So we just changed that into ASCII characters). Figure 6.11 represents the value before changing it. 

![Figure 6.11](/assets/img/PMA/Chapter_9/Lab9-1/Figure6.10)
<p align="center"> Figure 6.11 - Before pressing "A" </p>


![Figure 6.12](/assets/img/PMA/Chapter_9/Lab9-1/Figure6.12)
<p align="center"> Figure 6.12 - After pressing "A" </p>

Let's follow this in OllyDBG, as I think it is easier. 


Now, it compares our argument with "-in". If it is not -in, it jumps to _402B63_ which represents a cmp for checking if we have 3 arguments.


Upon further inspecting the program, I figured that in the very beggining, the malware checks for the __last__ argument. So, "abcd" should be the last character. 

# Work in progress